// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'library_item_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

LibraryItemResponse _$LibraryItemResponseFromJson(Map<String, dynamic> json) {
  return _LibraryItemResponse.fromJson(json);
}

/// @nodoc
mixin _$LibraryItemResponse {
  DetailedLibraryItem get result => throw _privateConstructorUsedError;
  int get total => throw _privateConstructorUsedError;
  int? get limit => throw _privateConstructorUsedError;
  int? get page => throw _privateConstructorUsedError;
  String? get sortBy => throw _privateConstructorUsedError;
  bool get sortDesc => throw _privateConstructorUsedError;
  String? get filterBy => throw _privateConstructorUsedError;
  String get mediaType => throw _privateConstructorUsedError;
  bool get minified => throw _privateConstructorUsedError;
  bool get collapseseries => throw _privateConstructorUsedError;
  String? get include => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LibraryItemResponseCopyWith<LibraryItemResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LibraryItemResponseCopyWith<$Res> {
  factory $LibraryItemResponseCopyWith(
          LibraryItemResponse value, $Res Function(LibraryItemResponse) then) =
      _$LibraryItemResponseCopyWithImpl<$Res, LibraryItemResponse>;
  @useResult
  $Res call(
      {DetailedLibraryItem result,
      int total,
      int? limit,
      int? page,
      String? sortBy,
      bool sortDesc,
      String? filterBy,
      String mediaType,
      bool minified,
      bool collapseseries,
      String? include});

  $DetailedLibraryItemCopyWith<$Res> get result;
}

/// @nodoc
class _$LibraryItemResponseCopyWithImpl<$Res, $Val extends LibraryItemResponse>
    implements $LibraryItemResponseCopyWith<$Res> {
  _$LibraryItemResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
    Object? total = null,
    Object? limit = freezed,
    Object? page = freezed,
    Object? sortBy = freezed,
    Object? sortDesc = null,
    Object? filterBy = freezed,
    Object? mediaType = null,
    Object? minified = null,
    Object? collapseseries = null,
    Object? include = freezed,
  }) {
    return _then(_value.copyWith(
      result: null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as DetailedLibraryItem,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      sortBy: freezed == sortBy
          ? _value.sortBy
          : sortBy // ignore: cast_nullable_to_non_nullable
              as String?,
      sortDesc: null == sortDesc
          ? _value.sortDesc
          : sortDesc // ignore: cast_nullable_to_non_nullable
              as bool,
      filterBy: freezed == filterBy
          ? _value.filterBy
          : filterBy // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: null == mediaType
          ? _value.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String,
      minified: null == minified
          ? _value.minified
          : minified // ignore: cast_nullable_to_non_nullable
              as bool,
      collapseseries: null == collapseseries
          ? _value.collapseseries
          : collapseseries // ignore: cast_nullable_to_non_nullable
              as bool,
      include: freezed == include
          ? _value.include
          : include // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DetailedLibraryItemCopyWith<$Res> get result {
    return $DetailedLibraryItemCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LibraryItemResponseImplCopyWith<$Res>
    implements $LibraryItemResponseCopyWith<$Res> {
  factory _$$LibraryItemResponseImplCopyWith(_$LibraryItemResponseImpl value,
          $Res Function(_$LibraryItemResponseImpl) then) =
      __$$LibraryItemResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DetailedLibraryItem result,
      int total,
      int? limit,
      int? page,
      String? sortBy,
      bool sortDesc,
      String? filterBy,
      String mediaType,
      bool minified,
      bool collapseseries,
      String? include});

  @override
  $DetailedLibraryItemCopyWith<$Res> get result;
}

/// @nodoc
class __$$LibraryItemResponseImplCopyWithImpl<$Res>
    extends _$LibraryItemResponseCopyWithImpl<$Res, _$LibraryItemResponseImpl>
    implements _$$LibraryItemResponseImplCopyWith<$Res> {
  __$$LibraryItemResponseImplCopyWithImpl(_$LibraryItemResponseImpl _value,
      $Res Function(_$LibraryItemResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
    Object? total = null,
    Object? limit = freezed,
    Object? page = freezed,
    Object? sortBy = freezed,
    Object? sortDesc = null,
    Object? filterBy = freezed,
    Object? mediaType = null,
    Object? minified = null,
    Object? collapseseries = null,
    Object? include = freezed,
  }) {
    return _then(_$LibraryItemResponseImpl(
      result: null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as DetailedLibraryItem,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      sortBy: freezed == sortBy
          ? _value.sortBy
          : sortBy // ignore: cast_nullable_to_non_nullable
              as String?,
      sortDesc: null == sortDesc
          ? _value.sortDesc
          : sortDesc // ignore: cast_nullable_to_non_nullable
              as bool,
      filterBy: freezed == filterBy
          ? _value.filterBy
          : filterBy // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaType: null == mediaType
          ? _value.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String,
      minified: null == minified
          ? _value.minified
          : minified // ignore: cast_nullable_to_non_nullable
              as bool,
      collapseseries: null == collapseseries
          ? _value.collapseseries
          : collapseseries // ignore: cast_nullable_to_non_nullable
              as bool,
      include: freezed == include
          ? _value.include
          : include // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LibraryItemResponseImpl implements _LibraryItemResponse {
  const _$LibraryItemResponseImpl(
      {required this.result,
      required this.total,
      this.limit,
      this.page,
      this.sortBy,
      required this.sortDesc,
      this.filterBy,
      required this.mediaType,
      required this.minified,
      required this.collapseseries,
      this.include});

  factory _$LibraryItemResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$LibraryItemResponseImplFromJson(json);

  @override
  final DetailedLibraryItem result;
  @override
  final int total;
  @override
  final int? limit;
  @override
  final int? page;
  @override
  final String? sortBy;
  @override
  final bool sortDesc;
  @override
  final String? filterBy;
  @override
  final String mediaType;
  @override
  final bool minified;
  @override
  final bool collapseseries;
  @override
  final String? include;

  @override
  String toString() {
    return 'LibraryItemResponse(result: $result, total: $total, limit: $limit, page: $page, sortBy: $sortBy, sortDesc: $sortDesc, filterBy: $filterBy, mediaType: $mediaType, minified: $minified, collapseseries: $collapseseries, include: $include)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LibraryItemResponseImpl &&
            (identical(other.result, result) || other.result == result) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.sortBy, sortBy) || other.sortBy == sortBy) &&
            (identical(other.sortDesc, sortDesc) ||
                other.sortDesc == sortDesc) &&
            (identical(other.filterBy, filterBy) ||
                other.filterBy == filterBy) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.minified, minified) ||
                other.minified == minified) &&
            (identical(other.collapseseries, collapseseries) ||
                other.collapseseries == collapseseries) &&
            (identical(other.include, include) || other.include == include));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, result, total, limit, page,
      sortBy, sortDesc, filterBy, mediaType, minified, collapseseries, include);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LibraryItemResponseImplCopyWith<_$LibraryItemResponseImpl> get copyWith =>
      __$$LibraryItemResponseImplCopyWithImpl<_$LibraryItemResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LibraryItemResponseImplToJson(
      this,
    );
  }
}

abstract class _LibraryItemResponse implements LibraryItemResponse {
  const factory _LibraryItemResponse(
      {required final DetailedLibraryItem result,
      required final int total,
      final int? limit,
      final int? page,
      final String? sortBy,
      required final bool sortDesc,
      final String? filterBy,
      required final String mediaType,
      required final bool minified,
      required final bool collapseseries,
      final String? include}) = _$LibraryItemResponseImpl;

  factory _LibraryItemResponse.fromJson(Map<String, dynamic> json) =
      _$LibraryItemResponseImpl.fromJson;

  @override
  DetailedLibraryItem get result;
  @override
  int get total;
  @override
  int? get limit;
  @override
  int? get page;
  @override
  String? get sortBy;
  @override
  bool get sortDesc;
  @override
  String? get filterBy;
  @override
  String get mediaType;
  @override
  bool get minified;
  @override
  bool get collapseseries;
  @override
  String? get include;
  @override
  @JsonKey(ignore: true)
  _$$LibraryItemResponseImplCopyWith<_$LibraryItemResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
