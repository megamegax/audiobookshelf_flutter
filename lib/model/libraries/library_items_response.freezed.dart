// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'library_items_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

LibraryItemsResponse _$LibraryItemsResponseFromJson(Map<String, dynamic> json) {
  return _LibraryItemsResponse.fromJson(json);
}

/// @nodoc
mixin _$LibraryItemsResponse {
  List<LibraryItem> get results => throw _privateConstructorUsedError;
  int get total => throw _privateConstructorUsedError;
  int get limit => throw _privateConstructorUsedError;
  int get page => throw _privateConstructorUsedError;
  bool get sortDesc => throw _privateConstructorUsedError;
  String get mediaType => throw _privateConstructorUsedError;
  bool get minified => throw _privateConstructorUsedError;
  bool get collapseseries => throw _privateConstructorUsedError;
  String get include => throw _privateConstructorUsedError;
  int get offset => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LibraryItemsResponseCopyWith<LibraryItemsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LibraryItemsResponseCopyWith<$Res> {
  factory $LibraryItemsResponseCopyWith(LibraryItemsResponse value,
          $Res Function(LibraryItemsResponse) then) =
      _$LibraryItemsResponseCopyWithImpl<$Res, LibraryItemsResponse>;
  @useResult
  $Res call(
      {List<LibraryItem> results,
      int total,
      int limit,
      int page,
      bool sortDesc,
      String mediaType,
      bool minified,
      bool collapseseries,
      String include,
      int offset});
}

/// @nodoc
class _$LibraryItemsResponseCopyWithImpl<$Res,
        $Val extends LibraryItemsResponse>
    implements $LibraryItemsResponseCopyWith<$Res> {
  _$LibraryItemsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? results = null,
    Object? total = null,
    Object? limit = null,
    Object? page = null,
    Object? sortDesc = null,
    Object? mediaType = null,
    Object? minified = null,
    Object? collapseseries = null,
    Object? include = null,
    Object? offset = null,
  }) {
    return _then(_value.copyWith(
      results: null == results
          ? _value.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<LibraryItem>,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      sortDesc: null == sortDesc
          ? _value.sortDesc
          : sortDesc // ignore: cast_nullable_to_non_nullable
              as bool,
      mediaType: null == mediaType
          ? _value.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String,
      minified: null == minified
          ? _value.minified
          : minified // ignore: cast_nullable_to_non_nullable
              as bool,
      collapseseries: null == collapseseries
          ? _value.collapseseries
          : collapseseries // ignore: cast_nullable_to_non_nullable
              as bool,
      include: null == include
          ? _value.include
          : include // ignore: cast_nullable_to_non_nullable
              as String,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LibraryItemsResponseImplCopyWith<$Res>
    implements $LibraryItemsResponseCopyWith<$Res> {
  factory _$$LibraryItemsResponseImplCopyWith(_$LibraryItemsResponseImpl value,
          $Res Function(_$LibraryItemsResponseImpl) then) =
      __$$LibraryItemsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<LibraryItem> results,
      int total,
      int limit,
      int page,
      bool sortDesc,
      String mediaType,
      bool minified,
      bool collapseseries,
      String include,
      int offset});
}

/// @nodoc
class __$$LibraryItemsResponseImplCopyWithImpl<$Res>
    extends _$LibraryItemsResponseCopyWithImpl<$Res, _$LibraryItemsResponseImpl>
    implements _$$LibraryItemsResponseImplCopyWith<$Res> {
  __$$LibraryItemsResponseImplCopyWithImpl(_$LibraryItemsResponseImpl _value,
      $Res Function(_$LibraryItemsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? results = null,
    Object? total = null,
    Object? limit = null,
    Object? page = null,
    Object? sortDesc = null,
    Object? mediaType = null,
    Object? minified = null,
    Object? collapseseries = null,
    Object? include = null,
    Object? offset = null,
  }) {
    return _then(_$LibraryItemsResponseImpl(
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<LibraryItem>,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      sortDesc: null == sortDesc
          ? _value.sortDesc
          : sortDesc // ignore: cast_nullable_to_non_nullable
              as bool,
      mediaType: null == mediaType
          ? _value.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as String,
      minified: null == minified
          ? _value.minified
          : minified // ignore: cast_nullable_to_non_nullable
              as bool,
      collapseseries: null == collapseseries
          ? _value.collapseseries
          : collapseseries // ignore: cast_nullable_to_non_nullable
              as bool,
      include: null == include
          ? _value.include
          : include // ignore: cast_nullable_to_non_nullable
              as String,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LibraryItemsResponseImpl implements _LibraryItemsResponse {
  const _$LibraryItemsResponseImpl(
      {required final List<LibraryItem> results,
      required this.total,
      required this.limit,
      required this.page,
      required this.sortDesc,
      required this.mediaType,
      required this.minified,
      required this.collapseseries,
      required this.include,
      required this.offset})
      : _results = results;

  factory _$LibraryItemsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$LibraryItemsResponseImplFromJson(json);

  final List<LibraryItem> _results;
  @override
  List<LibraryItem> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  final int total;
  @override
  final int limit;
  @override
  final int page;
  @override
  final bool sortDesc;
  @override
  final String mediaType;
  @override
  final bool minified;
  @override
  final bool collapseseries;
  @override
  final String include;
  @override
  final int offset;

  @override
  String toString() {
    return 'LibraryItemsResponse(results: $results, total: $total, limit: $limit, page: $page, sortDesc: $sortDesc, mediaType: $mediaType, minified: $minified, collapseseries: $collapseseries, include: $include, offset: $offset)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LibraryItemsResponseImpl &&
            const DeepCollectionEquality().equals(other._results, _results) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.sortDesc, sortDesc) ||
                other.sortDesc == sortDesc) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.minified, minified) ||
                other.minified == minified) &&
            (identical(other.collapseseries, collapseseries) ||
                other.collapseseries == collapseseries) &&
            (identical(other.include, include) || other.include == include) &&
            (identical(other.offset, offset) || other.offset == offset));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_results),
      total,
      limit,
      page,
      sortDesc,
      mediaType,
      minified,
      collapseseries,
      include,
      offset);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LibraryItemsResponseImplCopyWith<_$LibraryItemsResponseImpl>
      get copyWith =>
          __$$LibraryItemsResponseImplCopyWithImpl<_$LibraryItemsResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LibraryItemsResponseImplToJson(
      this,
    );
  }
}

abstract class _LibraryItemsResponse implements LibraryItemsResponse {
  const factory _LibraryItemsResponse(
      {required final List<LibraryItem> results,
      required final int total,
      required final int limit,
      required final int page,
      required final bool sortDesc,
      required final String mediaType,
      required final bool minified,
      required final bool collapseseries,
      required final String include,
      required final int offset}) = _$LibraryItemsResponseImpl;

  factory _LibraryItemsResponse.fromJson(Map<String, dynamic> json) =
      _$LibraryItemsResponseImpl.fromJson;

  @override
  List<LibraryItem> get results;
  @override
  int get total;
  @override
  int get limit;
  @override
  int get page;
  @override
  bool get sortDesc;
  @override
  String get mediaType;
  @override
  bool get minified;
  @override
  bool get collapseseries;
  @override
  String get include;
  @override
  int get offset;
  @override
  @JsonKey(ignore: true)
  _$$LibraryItemsResponseImplCopyWith<_$LibraryItemsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}
